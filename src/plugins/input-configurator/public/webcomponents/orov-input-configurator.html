<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-list/iron-list.html">
<link rel="import" href="../orov-behaviors/orov-behavior.html">
<link rel="import" href="../paper-item/paper-item.html">">
<link rel="import" href="../paper-listbox/paper-listbox.html">">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<link rel="import" href="../paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="../paper-tooltip/paper-tooltip.html">
<link rel="import" href="../neon-animation/neon-animation.html">
<link rel="import" href="../paper-slider/paper-slider.html">

<dom-module name="orov-input-configurator">

    <style type="text/css">
                
        paper-button {
            margin-top: 2em;
        }

        paper-spinner {
            top: 2em;
            left: 4em;
            --paper-spinner-stroke-width: 4px;
        }

        section {
            position: relative;
            width: 100%;
            border: 1px solid #000;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        td, th {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }

        tr:nth-child(even) {
            background-color: #dddddd;
        }
        
        #tableContainer {
            overflow: auto;
            height: 400px;
        }

        #descriptionRow {
            width: 500px;
        }

        #duplicateInputToast {
            --paper-toast-background-color: red;
            --paper-toast-color: white;
        }

        #toasts {
            margin-top: 15%;
        }
        #stickyHeader {
            background-color: white;
        }

        #expRateSlider {

        }

        .green-button {
            color: #34A853;
        }

        .blue-button {
            color: #1c4472;
        }
        /**
        * KEYS.css
        *
        * A simple stylesheet for rendering beautiful keyboard-style elements.
        *
        * Author:  Michael HÃ¼neburg
        * Website: http://michaelhue.com/keyscss
        * License: MIT License (see LICENSE.txt)
        */

        /* Base style, essential for every key. */
        kbd, .key {
            display: inline;
            display: inline-block;
            min-width: 1em;
            padding: .2em .3em;
            font: normal .85em/1 "Lucida Grande", Lucida, Arial, sans-serif;
            text-align: center;
            text-decoration: none;
            -moz-border-radius: .3em;
            -webkit-border-radius: .3em;
            border-radius: .3em;
            border: none;
            cursor: pointer;
            -moz-user-select: none;
            -webkit-user-select: none;
            user-select: none;
        }
        kbd[title], .key[title] {
            cursor: help;
        }

        /* Dark style for display on light background. This is the default style. */
        kbd, kbd.dark, .dark-keys kbd, .key, .key.dark, .dark-keys .key {
            background: rgb(80, 80, 80);
            background: -moz-linear-gradient(top, rgb(60, 60, 60), rgb(80, 80, 80));
            background: -webkit-gradient(linear, left top, left bottom, from(rgb(60, 60, 60)), to(rgb(80, 80, 80)));
            color: rgb(250, 250, 250);
            text-shadow: -1px -1px 0 rgb(70, 70, 70);
            -moz-box-shadow: inset 0 0 1px rgb(150, 150, 150), inset 0 -.05em .4em rgb(80, 80, 80), 0 .1em 0 rgb(30, 30, 30), 0 .1em .1em rgba(0, 0, 0, .3);
            -webkit-box-shadow: inset 0 0 1px rgb(150, 150, 150), inset 0 -.05em .4em rgb(80, 80, 80), 0 .1em 0 rgb(30, 30, 30), 0 .1em .1em rgba(0, 0, 0, .3);
            box-shadow: inset 0 0 1px rgb(150, 150, 150), inset 0 -.05em .4em rgb(80, 80, 80), 0 .1em 0 rgb(30, 30, 30), 0 .1em .1em rgba(0, 0, 0, .3);
        }

        /* Light style for display on dark background. */
        kbd.light, .light-keys kbd, .key.light, .light-keys .key {
            background: rgb(250, 250, 250);
            background: -moz-linear-gradient(top, rgb(210, 210, 210), rgb(255, 255, 255));
            background: -webkit-gradient(linear, left top, left bottom, from(rgb(210, 210, 210)), to(rgb(255, 255, 255)));
            color:  rgb(50, 50, 50);
            text-shadow: 0 0 2px rgb(255, 255, 255);
            -moz-box-shadow: inset 0 0 1px rgb(255, 255, 255), inset 0 0 .4em rgb(200, 200, 200), 0 .1em 0 rgb(130, 130, 130), 0 .11em 0 rgba(0, 0, 0, .4), 0 .1em .11em rgba(0, 0, 0, .9);
            -webkit-box-shadow: inset 0 0 1px rgb(255, 255, 255), inset 0 0 .4em rgb(200, 200, 200), 0 .1em 0 rgb(130, 130, 130), 0 .11em 0 rgba(0, 0, 0, .4), 0 .1em .11em rgba(0, 0, 0, .9);
            box-shadow: inset 0 0 1px rgb(255, 255, 255), inset 0 0 .4em rgb(200, 200, 200), 0 .1em 0 rgb(130, 130, 130), 0 .11em 0 rgba(0, 0, 0, .4), 0 .1em .11em rgba(0, 0, 0, .9);
        }        
    </style>

    <template>

        
        <h2>{{__('Input Configurator - Beta')}}</h2>
        <p>
            {{__('Click on the button you want to change in the table below')}}
        </p>        
        
        <h3> {{__('Button Controls')}} </h3>
        <section>      
            <div id="tableContainer">
                <table>
                    <thead id="stickyHeader">
                        <tr>
                            <th>
                                <div>{{__('Description')}}</div>
                            </th>
                            <th>
                                <div>{{__('Keyboard')}}</div>
                            </th>
                            <th>
                                <div>{{__('Gamepad')}}</div>
                            </th>     
                            <th>
                                <div>{{__('Emitter Name')}}</div>
                            </th>          
                        </tr>
                    </thead>
                    <tbody>
                        <template is="dom-repeat" items="[[buttonArray]]">
                            <tr>
                                <td id="descriptionRow">{{__(item.description)}}</td>
                                <td><kbd class="light" on-tap="handleKeyboardChange">{{item.bindings.keyboard.name}}&nbsp;</kbd></td>
                                <td><kbd on-tap="handleGamepadChange">{{item.bindings.gamepad.name}}&nbsp;</kbd></td>
                                <td>{{__(item.name)}}</td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>
        </section>

        <h3> {{__('Axis Controls')}} </h3>

        <section>      
            <div id="tableContainer" style="height:150px">
                <table>
                    <thead id="stickyHeader">
                        <tr>
                            <th>
                                <div>{{__('Description')}}</div>
                            </th>
                            <th>
                                <div>{{__('Gamepad')}}</div>
                            </th>     
                            <th>
                                <div>{{__('Emitter Name')}}</div>
                            </th>          
                        </tr>
                    </thead>
                    <tbody>
                        <template is="dom-repeat" items="[[axisArray]]">
                            <tr>
                                <td id="descriptionRow">{{__(item.description)}}</td>
                                <td><kbd on-tap="handleAxisChange">{{item.bindings.gamepad.name}}&nbsp;</kbd></td>
                                <td>{{__(item.name)}}</td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>
        </section>


        <paper-dialog id="keyboardModal" modal entry-animation="scale-up-animation" exit-animation="scale-down-animation" on-iron-overlay-closed="onKeyboardModalClosed" on-iron-overlay-opened="handleKeyboardFocus">
            <h1> {{__('Keyboard mapping:')}} {{selectedItem.name}} </h1>
            <p> {{__('Click REMAP and then enter the desired key to set this control')}} </p>
            <p> {{__('Click CLEAR to remove inputs associated with this command')}} </p>
            <h3>
                {{__('Current Mapping')}}: <paper-button on-tap="handleKeyboardRemapping"><kbd class="light">{{selectedItem.bindings.keyboard.name}}</kbd> </paper-button>
                <paper-spinner active={{isListeningToKeyboard}} text="Waiting for keyboard input">{{__('Waiting for keyboard input')}}</paper-spinner>
            </h3>
            
            <h3>
                {{__('Remap to')}}: <kbd class="light"> {{candidateBinding}} </kbd>
            </h3>

            <div class="buttons">
                <paper-button on-click="handleKeyboardRemapping"> {{__('Remap')}}</paper-button>
                <paper-button on-tap="handleClearKeyboardBinding" dialog-confirm>{{__('Clear')}}</paper-button>
                <paper-button disabled$={{isValidKeyboardReplacement}} on-tap="openClearKeyboardDuplicateWarning"> {{__('Clear conflicting binding')}} </paper-button>
                <paper-button dialog-dismiss>{{__('Cancel')}}</paper-button>
            </div>

            <paper-dialog id="clearKeyboardDuplicateWarningModal">
                <h2>{{__('Are you sure?')}}</h2>
                <p>{{__('Confirming this will clear the binding to ')}} <b>{{conflictingBinding.name}}</b>  {{__(' and set ')}} <kbd>{{candidateBinding}}</kbd> {{__(' as the binding to ')}} <b>{{selectedItem.name}}</b> </p>
                <div class="buttons">
                    <paper-button dialog-confirm on-tap="handleClearConflictingKeyboardBinding" class="green-button">{{__('Confirm')}}</paper-button>
                    <paper-button dialog-dismiss>{{__('Decline')}}</paper-button>
                </div>
            </paper-dialog>

        </paper-dialog>

        <paper-dialog id="gamepadModal" modal entry-animation="scale-up-animation" exit-animation="scale-down-animation" on-iron-overlay-closed="onGamepadModalClosed" on-iron-overlay-opened="handleGamepadFocus">
            <h1>{{__('Gamepad mapping:')}} {{selectedItem.name}}</h1>
            <p> {{__('Choose a control from the dropdown to remap this command to')}} </p>
            <p> {{__('Click CLEAR to remove inputs associated with this command')}} </p>

            <h3>
                {{__('Current Mapping')}}: <kbd>{{selectedItem.bindings.gamepad.name}}</kbd>
            </h3>

            <div>
                <paper-dropdown-menu id="candidategamepad" label="gamepad control">
                    <paper-listbox class="dropdown-content" attr-for-selected="value" selected="{{candidateBinding}}" on-iron-select="handleGamepadRemapping">
                        <paper-item value="A">{{__('A')}}</paper-item>
                        <paper-item value="B">{{__('B')}}</paper-item>
                        <paper-item value="X">{{__('X')}}</paper-item>
                        <paper-item value="Y">{{__('Y')}}</paper-item>
                        <paper-item value="LB">{{__('LB')}}</paper-item>
                        <paper-item value="RB">{{__('RB')}}</paper-item>
                        <paper-item value="LEFT_TRIGGER">{{__('LEFT_TRIGGER')}}</paper-item>
                        <paper-item value="RIGHT_TRIGGER">{{__('RIGHT_TRIGGER')}}</paper-item>
                        <paper-item value="LEFT_STICK">{{__('LEFT_STICK')}}</paper-item>
                        <paper-item value="RIGHT_STICK">{{__('RIGHT_STICK')}}</paper-item>
                        <paper-item value="START">{{__('START')}}</paper-item>
                        <paper-item value="BACK">{{__('BACK')}}</paper-item>
                        <paper-item value="HOME">{{__('HOME')}}</paper-item>
                        <paper-item value="DPAD_UP">{{__('DPAD_UP')}}</paper-item>
                        <paper-item value="DPAD_DOWN">{{__('DPAD_DOWN')}}</paper-item>
                        <paper-item value="DPAD_LEFT">{{__('DPAD_LEFT')}}</paper-item>
                        <paper-item value="DPAD_RIGHT">{{__('DPAD_RIGHT')}}</paper-item>
                    </paper-listbox>
                </paper-dropdown-menu>      
            </div>
            <div class="buttons">
                <paper-button disabled$={{isValidGamepadReplacement}} on-tap="openClearGamepadDuplicateWarning">{{__('Clear conflicting binding')}}</paper-button>
                <paper-button on-tap="handleClearGamepadBinding" dialog-confirm>{{__('Clear')}}</paper-button>
                <paper-button dialog-dismiss>{{__('Cancel')}}</paper-button>
            </div>
        </paper-dialog>
        
        <paper-dialog id="axisModal" modal entry-animation="scale-up-animation" exit-animation="scale-down-animation"on-iron-overlay-opened="handleGamepadFocus">
            <h1>{{__('Gamepad mapping:')}} {{selectedItem.name}}</h1>
            <p> {{__('Choose a control from the dropdown to remap this command to')}} </p>
            <p> {{__('Click CLEAR to remove inputs associated with this command')}} </p>

            <h3>
                {{__('Current Mapping')}}: <kbd>{{selectedItem.bindings.gamepad.name}}</kbd>
            </h3>

            <div>
                <paper-dropdown-menu id="candidategamepad" label="gamepad control">
                    <paper-listbox class="dropdown-content" attr-for-selected="value" selected="{{candidateBinding}}" on-iron-select="openAxisOptionsModal">
                        <paper-item value="LEFT_STICK_X">{{__('LEFT_STICK_X')}}</paper-item>
                        <paper-item value="LEFT_STICK_Y">{{__('LEFT_STICK_Y')}}</paper-item>
                        <paper-item value="RIGHT_STICK_X">{{__('RIGHT_STICK_X')}}</paper-item>
                        <paper-item value="RIGHT_STICK_Y">{{__('RIGHT_STICK_Y')}}</paper-item>
                    </paper-listbox>
                </paper-dropdown-menu>      
            </div>
            <paper-item>
                <paper-checkbox id="exponentialSticksCheckbox" checked="{{extraOptions.rovPilot.exponentialSticks}}" on-click="handleEnableExponentialSticks">{{__('Enable Exponential Sticks')}}</paper-checkbox>
            </paper-item>
            <div id="expRateSliderContainer">
                <paper-slider disabled="{{!extraOptions.rovPilot.exponentialSticks}}" id="expRateSlider" min="0" max="10" pin value="{{exponentialRate.current}}"></paper-slider>
            </div>
            <div class="buttons">
                <paper-button disabled$={{isValidGamepadReplacement}} on-tap="openClearGamepadDuplicateWarning">{{__('Clear conflicting binding')}}</paper-button>
                <paper-button on-tap="handleClearGamepadBinding" dialog-confirm>{{__('Clear')}}</paper-button>
                <paper-button dialog-dismiss>{{__('Close')}}</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="clearGamepadDuplicateWarningModal">
            <h2>{{__('Are you sure?')}}</h2>
            <p>{{__('Confirming this will clear the binding to ')}} <b>{{conflictingBinding.name}}</b>  {{__(' and set ')}} <kbd>{{candidateBinding}}</kbd> {{__(' as the binding to ')}} <b>{{selectedItem.name}}</b> </p>
            <div class="buttons">
                <paper-button dialog-confirm on-tap="handleClearConflictingGamepadBinding" class="green-button">{{__('Confirm')}}</paper-button>
                <paper-button dialog-dismiss>{{__('Decline')}}</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="axisOptionsModal">
            <h2>{{__('Axis Options')}}</h2>

            <h3> {{__('Selected:')}} <kbd>{{candidateBinding}}</kbd> </h3>

            <paper-listbox class="dropdown-content">
                <paper-item>
                    <paper-checkbox id="invertAxisCheckbox" checked="{{currentInversionSetting}}" on-tap="handleChangeInvert">{{__('Invert')}}</paper-checkbox>
                </paper-item>
            </paper-listbox>

            <div class="buttons">
                <paper-button dialog-confirm on-tap="handleAxisRemapping" class="green-button">{{__('Save')}}</paper-button>
                <paper-button dialog-dismiss>{{__('Close')}}</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="invalidGamepadTypeModal">
            <h2>{{__('Type mismatch!')}}</h2>
            <p><kbd>{{candidateBinding}}</kbd>  {{__(' is not a valid input command for ')}} <b>{{selectedItem.name}}</b> </p>
            <p>{{__('Select a different command')}}</p>
            <div class="buttons">
                <paper-button dialog-dismiss class="blue-button">{{__('OK')}}</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="savePresetModal" modal entry-animation="scale-up-animation" exit-animation="scale-down-animation" on-iron-overlay-closed="onSavePresetModalClosed">
            <h1>{{__('Save your current configuration')}}</h1>

            <paper-dropdown-menu id="savedPresetsDropdown" label="presets">
                <paper-listbox class="dropdown-content" attr-for-selected="value" selected="{{item.name}}" >
                    <template is="dom-repeat" items="[[savedPresets]]">
                        <paper-item value="{{item}}" on-tap="openOverridePresetModal">{{item}}</paper-item>
                    </template>
                    <paper-item on-tap="openSaveNewPresetModal"><iron-icon icon="save" item-icon></iron-icon>{{__('Save a new preset')}}</paper-item>                    
                </paper-listbox>
            </paper-dropdown-menu>

            <paper-dialog id="saveNewPresetModal" modal entry-animation="scale-up-animation" exit-animation="scale-down-animation"> 
                <h1>{{__('Enter a new preset name to save')}}</h1>
                <paper-input id="savePresetInput" label="preset name" on-keydown="checkForEnter" inputValue="{{candidatePreset}}" canrequired auto-validate char-counter maxlength="25" error-message="preset name needs some text!"></paper-input>
                <div class="buttons">
                    <paper-button dialog-dismiss on-tap="saveNewPreset" class="blue-button">{{__('Save')}}</paper-button>
                    <paper-button dialog-dismiss class="blue-button">{{__('Cancel')}}</paper-button>
                </div>
            </paper-dialog>

            <paper-dialog id="overridePresetModal" modal entry-animation="scale-up-animation" exit-animation="scale-down-animation"> 
                <h1>{{__('Are you sure? This will override your current saved settings for this preset')}}</h1>
                <div class="buttons">
                    <paper-button dialog-dismiss on-tap="overwritePreset" class="blue-button">{{__('SAVE')}}</paper-button>
                    <paper-button dialog-dismiss class="blue-button">{{__('Cancel')}}</paper-button>
                </div>
            </paper-dialog>
            
            <div class="buttons">
                <paper-button dialog-dismiss on-tap="overwritePreset" class="blue-button">{{__('SAVE')}}</paper-button>
                <paper-button dialog-dismiss class="blue-button">{{__('CANCEL')}}</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="loadPresetModal" modal entry-animation="scale-up-animation" exit-animation="scale-down-animation"  on-iron-overlay-closed="onLoadPresetModalClose">
            <h1>{{__('Choose a preset to load')}}</h1>
            <paper-dropdown-menu id="savedPresetsDropdown" label="presets">
                <paper-listbox class="dropdown-content" attr-for-selected="value" selected="{{candidatePreset}}" on-iron-select="handleLoadPreset">
                    <template is="dom-repeat" items="[[savedPresets]]">
                        <paper-item value="{{item}}">{{item}}</paper-item>
                    </template>
                </paper-listbox>
            </paper-dropdown-menu>
    
            <div class="buttons">
                <paper-button dialog-dismiss class="blue-button">{{__('CANCEL')}}</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="deletePresetModal" modal entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h1>{{__('Choose a preset to delete')}}</h1>
            <paper-dropdown-menu id="savedPresetsDropdown" label="presets">
                <paper-listbox class="dropdown-content" attr-for-selected="value">
                    <template is="dom-repeat" items="[[savedPresets]]">
                        <paper-item value="{{item}}" on-tap="openDeletePresetWarningModal">{{item}}</paper-item>
                    </template>
                </paper-listbox>
            </paper-dropdown-menu>
    
            <div class="buttons">
                <paper-button dialog-dismiss class="blue-button">{{__('CANCEL')}}</paper-button>
            </div>

            <paper-dialog id="deletePresetWarningModal">
                <h2>{{__('Are you sure?')}}</h2>
                <p>{{__('Confirming this will permanently delete preset:')}} <b>{{presetToDelete}}</b></p>
                <div class="buttons">
                    <paper-button dialog-confirm on-tap="handleDeletePreset" class="red-button">{{__('Confirm')}}</paper-button>
                    <paper-button dialog-dismiss>{{__('Decline')}}</paper-button>
                </div>
            </paper-dialog>
        </paper-dialog>

        <div class="buttons">
            <paper-button raised id="savePresetButton" on-tap="openSavePresetModal"><iron-icon icon="save"></iron-icon> {{__('Save Preset')}} </paper-button>
            <paper-button raised id="loadPresetButton" on-tap="openLoadPresetModal"><iron-icon icon="file-upload"></iron-icon> {{__('Load Preset')}}</paper-button>
            <paper-button raised id="deletePresetButton" on-tap="openDeletePresetModal"><iron-icon icon="delete"></iron-icon> {{__('Delete Preset')}} </paper-button>
        </div>

        <paper-dialog id="cannotOverwriteDefaultModal" modal entry-animation="scale-up-animation" exit-animation="scale-down-animation"> 
            <h2>{{__('Cannot override the default preset. Select a different preset')}}</h2>
            <div class="buttons">
                <paper-button dialog-dismiss class="blue-button">{{__('OK')}}</paper-button>
            </div>
        </paper-dialog>

        <p> {{__('Current Preset:')}} <b>{{preset.name}}</b>
            <template is="dom-if" if="{{isCustomConfig}}">
               <i>{{__('unsaved')}}</i>
            </template>
        </p>

        <div class="buttons" id="toasts">
            <p></p>
        </div>


        <!--Toasts-->
        <paper-toast id="updatedPresetToast" text="Updated Preset! Remember to save your new preset!"></paper-toast>
        <paper-toast id="clearedInputToast" text="Cleared input!"></paper-toast>
        <paper-toast id="savedPresetToast" text="Saved preset!"></paper-toast>
        <paper-toast id="loadedPresetToast" text="Loaded preset!"></paper-toast>
        <paper-toast id="deletedPresetToast" text="Deleted preset!"></paper-toast>
        <paper-toast id="duplicateInputToast" text="Duplicate found."></paper-toast>
        <paper-toast id="updatedExtraOptionsToast" text="Updated extra options!"></paper-toast>

        <paper-toast id="waitingForKeyboardInputToast"duration="0" text="Waiting for keyboard input"></paper-toast>

    </template>
    <script>

        //Helper function for sorting inputs
        function compare(a,b) 
        {
            if(a.name < b.name)
            {
                return -1;
            }
            if(a.name > b.name)
            {
                return 1;
            }
            return 0;
        };

        (function() {

            var keyboardMap = ["", "", "", "CANCEL", "", "", "HELP", "", "BACK_SPACE", "TAB", "", "", "CLEAR", "ENTER", "RETURN", "", "SHIFT", "CTRL", "ALT", "PAUSE", "CAPSLOCK", "KANA", "EISU", "JUNJA", "FINAL", "HANJA", "", "ESC", "CONVERT", "NONCONVERT", "ACCEPT", "MODECHANGE", "SPACE", "PAGE_UP", "PAGE_DOWN", "END", "HOME", "LEFT", "UP", "RIGHT", "DOWN", "SELECT", "PRINT", "EXECUTE", "PRINTSCREEN", "INSERT", "DELETE", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "LESS_THAN", "=", "GREATER_THAN", "QUESTION_MARK", "AT", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "WIN", "", "CONTEXT_MENU", "", "SLEEP", "NUMPAD0", "NUMPAD1", "NUMPAD2", "NUMPAD3", "NUMPAD4", "NUMPAD5", "NUMPAD6", "NUMPAD7", "NUMPAD8", "NUMPAD9", "MULTIPLY", "ADD", "SEPARATOR", "SUBTRACT", "DECIMAL", "DIVIDE", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "", "", "", "", "", "", "", "", "NUM_LOCK", "SCROLL_LOCK", "WIN_OEM_FJ_JISHO", "WIN_OEM_FJ_MASSHOU", "WIN_OEM_FJ_TOUROKU", "WIN_OEM_FJ_LOYA", "WIN_OEM_FJ_ROYA", "", "", "", "", "", "", "", "", "", "CIRCUMFLEX", "EXCLAMATION", "\"", "#", "$", "%", "&", "_", "(", ")", "*", "+", "|", "HYPHEN_MINUS", "{", "}", "~", "", "", "", "", "VOLUME_MUTE", "VOLUME_DOWN", "VOLUME_UP", "", "", ";", "=", ",", "-", ".", "/", "`", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[", "\\", "]", "'", "", "META", "ALTGR", "", "WIN_ICO_HELP", "WIN_ICO_00", "", "WIN_ICO_CLEAR", "", "", "WIN_OEM_RESET", "WIN_OEM_JUMP", "WIN_OEM_PA1", "WIN_OEM_PA2", "WIN_OEM_PA3", "WIN_OEM_WSCTRL", "WIN_OEM_CUSEL", "WIN_OEM_ATTN", "WIN_OEM_FINISH", "WIN_OEM_COPY", "WIN_OEM_AUTO", "WIN_OEM_ENLW", "WIN_OEM_BACKTAB", "ATTN", "CRSEL", "EXSEL", "EREOF", "PLAY", "ZOOM", "", "PA1", "WIN_OEM_CLEAR", ""];


            //Mapping of gamepad objects to type
            var gamepadTypes = [
                ["A", "button"],
                ["B", "button"],
                ["X", "button"],
                ["Y", "button"],
                ["LB", "button"],
                ["RB", "button"],
                ["LEFT_TRIGGER", "button"],
                ["RIGHT_TRIGGER", "button"],
                ["LEFT_STICK", "button"],
                ["RIGHT_STICK", "button"],
                ["START", "button"],
                ["BACK", "button"],
                ["HOME", "button"],
                ["DPAD_DOWN", "button"],
                ["DPAD_LEFT", "button"],
                ["DPAD_RIGHT", "button"],
                ["DPAD_UP", "button"],
                ["LEFT_STICK_X", "axis"],
                ["LEFT_STICK_Y", "axis"],
                ["RIGHT_STICK_X", "axis"],
                ["RIGHT_STICK_Y", "axis"]
            ];
            var gamepadMap = new Map(gamepadTypes);

            //Mapping of axis to inversions actions
            var axisInversions = [
                ["LEFT_STICK_X", {
                    plugin: "rovPilot",
                    item: "invertLeftX"}],
                ["LEFT_STICK_Y", {
                    plugin: "rovPilot",
                    item: "invertLeftY"}],
                ["RIGHT_STICK_X", {
                    plugin: "rovPilot",
                    item: "invertRightX"}],
                ["RIGHT_STICK_Y", {
                    plugin: "rovPilot",
                    item: "invertRightY"}]
            ];
            var inversionMap = new Map(axisInversions);

            Polymer({
                is: "orov-input-configurator",
                properties: {
                    actions: {
                        type: Map,
                        value: undefined
                    },
                    axisArray: {
                        type: Array,
                        value: []
                    },
                    buttonArray: {
                        type: Array,
                        value: []
                    },

                    candidateBinding: {
                        type: Object,
                        value: undefined
                    },
                    candidatePreset: {
                        type: String,
                        value: undefined
                    },
                    currentInversionSetting: {
                        type: Boolean,
                        value: undefined
                    },
                    defaultPresetName: {
                        type: String,
                        value: "defaults"
                    },
                    enableExponentialSticks: {
                        type: Boolean,
                        value: false,
                        observer: "enableExponentialSticksChanged"
                    },

                    extraOptions: {
                        type: Object,
                        value: {}
                    },
                    presetToDelete: {
                        type: String,
                        value: undefined
                    },
                    conflictingBinding: {
                        type: Object,
                        value: undefined
                    },

                    isCustomConfig: {
                        type: Boolean,
                        value: false
                    },

                    preset: {
                        type: Map
                    },

                    exponentialRate: {
                        type: Object,
                        value: {
                            current: {
                                type: Number,
                                value: 0
                            },
                            previous: {
                                type: Number,
                                value: 0
                            }
                        }
                    },
                    previousExpRate: {
                        type: Number,
                        value: undefined
                    },
                    presetArray: {
                        type: Array,
                        value: []
                    },
                    savedPresets: {
                        type: Array,
                        value: []
                    },

                    selectedItem: {
                        type: Object,
                        value: undefined
                    },
                    settings: {
                        type: Object,
                        value: undefined
                    },
                    isListeningToKeyboard: {
                        type: Boolean,
                        value: false
                    },

                    isValidKeyboardReplacement: {
                        type: Boolean,
                        value: true
                    },

                    isValidGamepadReplacement: {
                        type: Boolean,
                        value: true
                    }
                },
                
                behaviors: [namespace('behaviors').oROVStandard],

                listeners: {
                    'tableContainer.scroll': 'tableContainerScroll',
                    'expRateSlider.value-change': 'expRateSliderHandler'
                },


                registerEmitterHandlers: function(emitter) {
                    var self = this;
                    
                    this.presetFunction = function(preset, actions) {
                        //Shallow copy to aviod references
                        self.preset = self.copyPreset(preset);
                        self.actions = actions;

                        //Update the UI to reflect this
                        self.presetToArray(self.preset);
                    }.bind(this);

                    this.getSavedPresetListFunction = function(presets) {
                        
                        //Reset the internal state
                        if(self.savedPresets !== undefined)
                        {
                            self.splice('savedPresets', 0, self.savedPresets.length);
                            
                            //Avoid reference passing
                            for(var i = 0; i < presets.length; ++i)
                            {
                                self.push('savedPresets', presets[i]);
                            }
                        }
                        
                    }.bind(this);

                    this.getSettings = function(settings) {
                        self.set("settings", settings.inputConfigurator);

                        var extraOptions = self.settings.extraOptions;
                        if(self.settings.extraOptions !== undefined)
                        {
                            self.set("extraOptions", self.settings.extraOptions);
                            if(self.settings.extraOptions.rovPilot.exponentialRate == self.exponentialRate.previous)
                            {
                                //Don't do nothing
                            }
                            else
                            {
                                self.set("exponentialRate.current", self.settings.extraOptions.rovPilot.exponentialRate);
                                self.set("exponentialRate.previous", self.settings.extraOptions.rovPilot.exponentialRate);
                            }

                        }
                    }.bind(this);

                    emitter.on('plugin.inputController.updatedPreset', this.presetFunction );
                    emitter.on('plugin.inputConfigurator.savedPresets', this.getSavedPresetListFunction );
                    emitter.rov.on('settings-change.inputConfigurator', this.getSettings );
                },
                
                detached: function(){
                    this.eventEmitter.off('plugin.inputController.updatedPreset',this.presetFunction);
                    this.eventEmitter.off('plugin.inputConfigurator.savedPresets',this.getSavedPresetListFunction);
                    this.eventEmitter.rov.off('settings-change.inputConfigurator', this.getSettings );
                },

                attached: function() {
                    var self = this;
                    //Tell the input controller we want presets 
                    if(self.preset == undefined)
                    {
                        self.eventEmitter.emit('plugin.inputController.sendPreset');
                    }                    

                    //Fit the  most important toasts up
                    self.$.updatedPresetToast.fitInto = self.$.toasts;
                    self.$.duplicateInputToast.fitInto = self.$.toasts;
                    self.$.waitingForKeyboardInputToast.fitInto = self.$.toasts;
                    //Get the list of saved presets from disk
                    self.eventEmitter.emit('plugin.inputConfigurator.getSavedPresets', self.preset);  

                    //Get our settings as well
                    if(self.settings == undefined)
                    {
                        self.eventEmitter.rov.emit('plugin.settings-manager.getSettings', "inputConfigurator", function(settings) {
                            self.set("settings", settings.inputConfigurator);
                            self.set("extraOptions", self.settings.extraOptions);
                        });
                    }
                    
                },

                expRateSliderHandler: function(e) {
                    var self = this;
                    
                    var sliderValue = self.$.expRateSlider.value;
                    //Save this setting
                    if(self.settings !== undefined)
                    {
                        self.extraOptions.rovPilot.exponentialRate = sliderValue;
                        self.settings.extraOptions = self.extraOptions;

                        self.eventEmitter.rov.emit('plugin.settings-manager.saveSettings', {inputConfigurator: self.settings});
                        self.$.updatedExtraOptionsToast.open();
                    }

                },
                copyPreset: function(presetIn)
                {
                    var self = this;

                    var returnPreset = {
                        name: presetIn.name,
                        actions: new Map(),
                    };
                    
                    //Iterate through actions
                    presetIn.actions.forEach(function(action, actionName) {
                        var actionToAdd = new Map();

                        action.forEach(function(input, controllerName) {
                        actionToAdd.set(controllerName, jQuery.extend({}, input));  
                        });

                        returnPreset.actions.set(actionName, actionToAdd);
                    });
                    return returnPreset;
                },

                enableExponentialSticksChanged: function(newValue, oldValue)
                {
                    var self = this;
                    
                },

                extraOptionsChanged: function(newValue, oldValue)
                {
                    var self = this;
                    
                },

                handleEnableExponentialSticks: function()
                {
                    var self = this;
                    self.extraOptions.rovPilot.exponentialSticks = self.$.exponentialSticksCheckbox.checked;    
                    self.settings.extraOptions = self.extraOptions;
                    self.eventEmitter.rov.emit('plugin.settings-manager.saveSettings', {inputConfigurator: self.settings});
                    self.$.updatedExtraOptionsToast.open();
                },

                handleChangeInvert: function()
                {
                    var self = this;

                    var inversion = inversionMap.get(self.candidateBinding);
                    var extraOptionsPlugin = self.extraOptions[inversion.plugin];
                    extraOptionsPlugin[inversion.item] = self.$.invertAxisCheckbox.checked;;
                    
                    self.settings.extraOptions = self.extraOptions;
                    self.eventEmitter.rov.emit('plugin.settings-manager.saveSettings', {inputConfigurator: self.settings});
                    self.$.updatedExtraOptionsToast.open();
                },

                //Check if enter was pressed
                checkForEnter: function(e) {
                    var self = this;
                    if(e.keyCode == 13)
                    {
                        //Uncomment this to enable 'enter' key saving
                        self.saveNewPreset();
                    }
                },

                //Check for duplicated gamepad inputs
                checkForGamepadDuplicates: function() {
                    var self = this;

                    if(self.presetArray == undefined || self.candidateBinding == undefined)
                    {
                        return;
                    }

                    //Check if this is a valid binding
                    var isDuplicate = self.presetArray.some(function(element, index, array) {
                        self.conflictingBinding = element;
                        if(element.bindings.gamepad !== undefined)
                        {
                            return element.bindings.gamepad.name == self.candidateBinding;
                        }
                    });

                    if(isDuplicate)
                    {
                        self.openDuplicateInputToast();
                        self.isValidGamepadReplacement = false;                       
                    }
                    else
                    {
                        self.isValidGamepadReplacement = true;
                        self.updateGamepadInput();
                    }
                },

                //Check for duplicated keyboard inputs
                checkForKeyboardDuplicates: function() {
                    var self = this;

                    //If there is no array present to check with, return
                    if(self.presetArray == undefined || self.candidateBinding == undefined)
                    {
                        return;
                    }

                    //Check if this is a valid binding
                    var isDuplicate = self.presetArray.some(function(element, index, array) {
                        self.conflictingBinding = element;
                        if(element.bindings.keyboard !== undefined)
                        {
                            return element.bindings.keyboard.name == self.candidateBinding;
                        } 
                    });

                    if( isDuplicate )
                    {
                        self.isValidKeyboardReplacement = false;                       
                        self.openDuplicateInputToast();
                    }
                    else
                    {
                        self.isValidKeyboardReplacement = true;
                        self.updateKeyboardInput();
                    }
                },

                //Update an existing gamepad binding
                updateGamepadInput: function() {
                    var self = this;

                    var updatedInput = {
                        action: self.selectedItem.name,
                        input: {
                            name: self.candidateBinding,
                            controller: "gamepad",
                            type: gamepadMap.get(self.candidateBinding)
                        }
                    };
                    self.eventEmitter.emit('plugin.inputController.updateInput', updatedInput);

                    //Open the update toast
                    self.openUpdatePresetToast();

                    //And close the modal
                    self.$.gamepadModal.close();
                    self.$.axisModal.close();
                },

                //Update an existing keyboard binding
                updateKeyboardInput: function() {
                    var self = this;

                    
                    var updatedInput = {
                        action: self.selectedItem.name,
                        input: {
                            name: self.candidateBinding,
                            controller: "keyboard",
                            type: "button"
                        }
                    };

                    self.eventEmitter.emit('plugin.inputController.updateInput', updatedInput);

                    //Open the update toast
                    self.openUpdatePresetToast();

                    //And close the modal
                    self.$.keyboardModal.close();
                },

                //Delete a preset
                handleDeletePreset: function()
                {
                    var self = this;

                    if(self.presetToDelete == self.defaultPresetName)
                    {
                        self.$.cannotOverwriteDefaultModal.open();
                        self.$.deletePresetModal.close();
                    }
                    else
                    {
                        //Delete from input controller
                        self.eventEmitter.emit('plugin.inputConfigurator.deletePreset', self.presetToDelete);
                        self.$.deletePresetModal.close();
                        self.$.deletedPresetToast.open();
                    }
                },

                //Clear a conflicting gamepad binding
                handleClearConflictingGamepadBinding: function() {
                    var self = this;

                    //Format in a way that the input controller expects
                    var clearedInput = {
                        action: self.conflictingBinding.name,
                        input: self.conflictingBinding.bindings.gamepad
                    };

                    //Let the input controller know
                    self.eventEmitter.emit('plugin.inputController.unregisterInput', clearedInput);

                    self.isCustomConfig = true;
                    self.updateGamepadInput();
                    self.openUpdatePresetToast();
                }, 

                //Clear a conflicting keyboard binding
                handleClearConflictingKeyboardBinding: function() {
                    var self = this;

                    //Format in a way that the input controller expects
                    var clearedInput = {
                        action: self.conflictingBinding.name,
                        input: self.conflictingBinding.bindings.keyboard
                    };

                    //Let the input controller know
                    self.eventEmitter.emit('plugin.inputController.unregisterInput', clearedInput);
                    
                    self.isCustomConfig = true;
                    self.updateKeyboardInput();
                    self.openUpdatePresetToast();
                },

                //Handles clearing an existing gamepad command
                handleClearGamepadBinding: function() {
                    var self = this;

                    if(self.selectedItem.bindings.gamepad !== undefined)
                    {         
                        //Clear the input from our presets
                        //Let the input controller know
                        var clearedInput = {
                            action: self.selectedItem.name,
                            input: self.selectedItem.bindings.gamepad
                        };

                        self.eventEmitter.emit('plugin.inputController.unregisterInput', clearedInput);
                    }

                    self.isCustomConfig = true;
                    this.$.clearedInputToast.open();
                },

                //Handles clearing an existing keyboard command
                handleClearKeyboardBinding: function() {
                    var self = this;

                    if(self.selectedItem.bindings.keyboard !== undefined)
                    {
                        //Clear the input from our presets
                        //Let the input controller know the new configurations
                        var clearedInput = {
                            action: self.selectedItem.name,
                            input: self.selectedItem.bindings.keyboard
                        };
                        self.eventEmitter.emit('plugin.inputController.unregisterInput', clearedInput);
                    }

                    self.isCustomConfig = true;
                    this.$.clearedInputToast.open();
                },
                
                //User has clicked a gamepad symbol
                handleGamepadChange: function(e) {
                    var self = this;
                    var inputPressed = e.model.item;
                    self.selectedItem = inputPressed;
                    
                    this.$.gamepadModal.open();
                },

                handleAxisChange: function(e) {
                    var self = this;
                    self.selectedItem = e.model.item;
                    self.openAxisModal()
                },

                //Gamepad modal has opened
                handleGamepadFocus: function(e) {
                    var self = this;

                    //Reset our state
                    self.isValidGamepadReplacement = true;
                },

                //Handle the selection for the gamepad
                handleGamepadRemapping: function(e) {
                    var self = this;

                    if(self.candidateBinding == null)
                    {
                        self.handleClearGamepadBinding();
                    }

                    //Check to make sure this is a valid input for this action
                    if(self.hasActionType(self.selectedItem.name, gamepadMap.get(self.candidateBinding)))
                    {
                        self.checkForGamepadDuplicates();
                    }
                    else
                    {
                        self.openInvalidGamepadTypeModal();
                    }
                    
                },

                openExtraOptionsModal: function()
                {
                    var self = this;
                    self.$.extraOptionsModal.open();
                },

                handleExtraOptions: function()
                {
                    var self = this;

                    var invertLeft = self.$.invertLeftYAxisCheckbox.checked;
                    var invertRight = self.$.invertRightYAxisCheckbox.checked;
                    var exponentialSticks = self.$.exponentialSticksCheckbox.checked;

                    var extraOptionsPayload = {
                        invertLeft: invertLeft,
                        invertRight: invertRight,
                        exponentialSticks: exponentialSticks
                    };
                    self.eventEmitter.emit('plugin.inputConfigurator.extraOptionsChanged', extraOptionsPayload);
                },
                openAxisModal: function()
                {
                    var self = this;

                    self.$.axisModal.open();
                },

                //User has clicked a keyboard symbol
                handleKeyboardChange: function(e) {
                    var self = this;
                    var inputPressed = e.model.item;
                    self.selectedItem = inputPressed;
                    
                    this.$.keyboardModal.open();
                },

                //Keyboard modal has opened
                handleKeyboardFocus: function(e) {
                    var self = this;

                    //Reset our state
                    self.isListeningToKeyboard = false;
                    self.isValidKeyboardReplacement = true;
                },

                handleKeyboardRemapping: function() {
                    var self = this;

                    //Start listening for keyboard inputs
                    self.isListeningToKeyboard = true;

                    //Open the toast
                    self.$.waitingForKeyboardInputToast.open();

                    Mousetrap.record( function(sequence) {
                        self.isListeningToKeyboard = false;
                        self.candidateBinding = sequence.join(' ');

                        //Check to see if this is a valid replacement binding for the keyboard
                        self.checkForKeyboardDuplicates();
                    });

                },

                handleLoadPreset: function()
                {
                    var self = this;
                    
                    //Request the node module to send up the preset requested
                    self.eventEmitter.emit('plugin.inputConfigurator.loadPreset', self.candidatePreset);

                    self.candidatePreset = undefined;
                    self.openLoadedPresetToast();
                    self.$.loadPresetModal.close();
                },

                saveNewPreset: function()
                {
                    var self = this;
                    var presetName = self.$.savePresetInput.value;
                    
                    if(presetName)
                    {
                        self.handleSavePreset(presetName);
                    }
                },

                handleSavePreset: function(presetName)
                {
                    var self = this;

                    if(presetName == self.defaultPresetName)
                    {
                        self.$.cannotOverwriteDefaultModal.open();
                    }
                    else
                    {
                        self.set('preset.name', presetName);
                        
                        self.eventEmitter.emit('plugin.inputConfigurator.savePreset', self.preset);
                        self.$.savePresetModal.close();
                        self.openSavedPresetToast();
                    }

                },

                onLoadPresetModalClose: function()
                {
                    var self = this;
                    self.candidatePreset = undefined;
                },

                openOverridePresetModal: function(oEvent)
                {
                    var self = this;
                    candidatePreset = oEvent.model.get('item');
                    self.$.overridePresetModal.open();
                },

                openSavePresetModal: function()
                {
                    var self = this;
                    
                    self.$.savePresetModal.open();
                },

                openLoadPresetModal: function()
                {
                    var self = this;                
                    self.$.loadPresetModal.open();
                },

                overwritePreset: function(oEvent)
                {
                    var self = this;
                    self.handleSavePreset(candidatePreset);  
                },

                openDeletePresetModal: function()
                {
                    var self = this;
                    self.$.deletePresetModal.open();
                },
                
                openAxisOptionsModal: function()
                {
                    var self = this;

                    //Get the settings for this inversion
                    var inversion = inversionMap.get(self.candidateBinding);
                    var extraOptionsPlugin = self.extraOptions[inversion.plugin];
                    self.currentInversionSetting = extraOptionsPlugin[inversion.item];

                    self.$.axisOptionsModal.open();
                },

                handleAxisRemapping: function()
                {
                    var self = this;
                    self.handleGamepadRemapping();
                },
                openDeletePresetWarningModal: function(oEvent)
                {
                    var self = this;

                    self.presetToDelete = oEvent.model.get('item');
                    self.$.deletePresetWarningModal.open();
                },

                openSaveNewPresetModal: function()
                {
                    var self = this;
                    self.$.saveNewPresetModal.open();
                },

                //Checks to see if this action accepts this type
                hasActionType: function(actionName, typeIn) {
                    var self = this;

                    //Get the action
                    var action = self.actions.get(actionName);

                    for(var type in action.controls)
                    {
                        //If this type is equivalent, we are ok
                        if(type == typeIn)
                        {
                            return true;
                        }
                    }

                    return false;
                },

                onKeyboardModalClosed : function() {
                    var self = this;
                    self.$.waitingForKeyboardInputToast.close();
                },

                onGamepadModalClosed : function() {
                    var self = this;  
                },
                onSavePresetModalClosed: function() {
                    var self = this;

                    //Reset the candidatePreset
                    self.candidatePreset = undefined;
                },

                //Toasts and modals
                openClearGamepadDuplicateWarning: function() {
                    var self = this;
                    self.$.clearGamepadDuplicateWarningModal.open();
                },
                openClearKeyboardDuplicateWarning: function() {
                    var self = this;
                    self.$.clearKeyboardDuplicateWarningModal.open();
                },
                openDuplicateInputToast: function() {
                    this.$.duplicateInputToast.open();
                },
                openInvalidGamepadTypeModal: function() {
                    var self = this;
                    self.$.invalidGamepadTypeModal.open();
                },
                openUpdatePresetToast: function() {
                    var self = this;

                    self.candidateBinding = undefined;
                    self.isCustomConfig = true;

                    self.$.updatedPresetToast.open();
                },
                openSavedPresetToast: function() {
                    var self = this;

                    self.isCustomConfig = false;
                    self.$.savedPresetToast.open();
                },
                openLoadedPresetToast: function() {
                    var self = this;

                    self.$.loadedPresetToast.open();
                },


                //Converts a preset object(hash map) to a consumable array for the input configurator
                presetToArray: function(preset) {
                    var self = this;

                    //array for buttons
                    var buttons = [];
                    var axes = [];
                    
                    var arrayPreset = [];

                    preset.actions.forEach(function(action, actionName) {
                        var isAxis = false;
                        var controls = self.actions.get(actionName).controls;

                        for(var control in controls)
                        {
                            if(control == "axis")
                            {
                                //This command takes axis commands, dump into the axis array instead of the button array
                                isAxis = true;
                            }
                        }

                        var binding = {
                            keyboard: undefined,
                            gamepad: undefined
                        };

                        action.forEach(function(input, controllerName) {

                            binding[controllerName] = input;
                        }); 

                        var arrayInput = {
                            name: actionName,
                            description: self.actions.get(actionName).description,
                            bindings: binding
                        };

                        arrayPreset.push(arrayInput);
                        if(isAxis)
                        {
                            axes.push(arrayInput);
                        }
                        else
                        {
                            buttons.push(arrayInput);
                        }
                    });

                    arrayPreset.sort(compare);
                    axes.sort(compare);
                    buttons.sort(compare);

                    self.presetArray = arrayPreset;
                    self.axisArray = axes;
                    self.buttonArray = buttons;

                    return arrayPreset;
                },

                //Function to achieve the sticky table headers with pure CSS.
                tableContainerScroll: function() {
                    var self = this;

                    /*CSS way to do sticky headers*/
                    var translate = "translate(0," + self.$.tableContainer.scrollTop + "px)";
                    self.$.stickyHeader.style.transform = translate;
                }
            })
        })();
    </script>

</dom-module>